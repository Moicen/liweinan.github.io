<p>In the previous articles, we have learned the basic aspects of the JDBC specification and the implementation of the PostgreSQL driver. In this article, I’d like to go on checking another important part of the JDBC specification(<a href="http://download.oracle.com/otn-pub/jcp/jdbc-4_1-mrel-spec/jdbc4.1-fr-spec.pdf?AuthParam=1494474283_bf1014b01227d16877a00b038e2e7e82">JDBC™ 4.1  Specification</a>): Connection pooling.</p>

<p>In JDBC specification, it defines a three-tier layer structure for the users to get connection from a managed data source pool. Here is the diagram from the specification:</p>

<p><img src="/assets/jdbc/pooling.png" alt="/assets/jdbc/pooling.png" /></p>

<p>In above diagram, we can see the data source is designed to be provided by application server. For example, Wildfly as an application server should take the responsibility to provide a database connection pool to the users. On the JDBC driver layer, it needs to implement two interfaces defined by JDBC specification. Here is the class diagram of the two interfaces:</p>

<p><img src="/assets/jdbc/interfaces.png" alt="/assets/jdbc/interfaces.png" /></p>

<p>The above diagram shows the two interfaces from JDK source that should be implemented by the JDBC driver, which are <code class="highlighter-rouge">javax.sql.PooledConnection</code> and <code class="highlighter-rouge">javax.sql.ConnectionPoolDataSource</code>.</p>

<p>From the above diagram, we can see the <code class="highlighter-rouge">ConnectionPoolDataSource</code> interface defines a <code class="highlighter-rouge">getPooledConnection()</code> method that will return a <code class="highlighter-rouge">javax.sql.PooledConnection</code> typed data.</p>

<p>The <code class="highlighter-rouge">PooledConnection</code> interface defines the <code class="highlighter-rouge">getConnection()</code> method that will return a <code class="highlighter-rouge">java.sql.Connection</code> typed data.</p>

<p>The purpose of the design is to allow the implementation of the <code class="highlighter-rouge">PooledConnection</code> and <code class="highlighter-rouge">ConnectionPoolDataSource</code> to manage the underlying <code class="highlighter-rouge">Connection</code> to the database. In this way, the JDBC driver can handle the <code class="highlighter-rouge">Connection</code> instance returned from <code class="highlighter-rouge">PooledConnection</code> to manage its lifecycle the data pool.</p>

<p>Here is the class diagram about the implementation of the above two interfaces in PostgreSQL JDBC driver:</p>

<p><img src="/assets/jdbc/org.postgresql.ds.png" alt="/assets/jdbc/org.postgresql.ds.png" /></p>

<p>The above diagram shows the implementation of the interfaces in the driver. The <code class="highlighter-rouge">org.postgresql.ds.PGPooledConnection</code> implements the <code class="highlighter-rouge">javax.sql.PooledConnection</code> interface, and the <code class="highlighter-rouge">org.postgresql.ds.PGConnectionPoolDataSource</code> implements the <code class="highlighter-rouge">javax.sql.ConnectionPoolDataSource</code>. We will check the design of these two classes later in the article.</p>

<p>These two interfaces do not care about the detail pool implementation, and usually in application server the connection pool implementation can be configured and replaced with multiple choices.</p>

<p>In this article, I won’t use an application server as the datasource provider. In PostgreSQL JDBC driver, it provides a sample pooling implementation class named <code class="highlighter-rouge">org.postgresql.ds.PGPoolingDataSource</code>. We will use it as our demonstration implementation in this article.</p>

<p>Firstly, let’s write a class to use the <code class="highlighter-rouge">org.postgresql.ds.PGPoolingDataSource</code> to fetch a connection from the pool:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>package io.weinan.jdbc;

import org.postgresql.ds.PGPoolingDataSource;

/**
 * Created by weli on 01/05/2017.
 */
public class PlayWithPGPoolingDataSource {

    public static void main(String[] args) throws Exception {
        PGPoolingDataSource dataSource = new PGPoolingDataSource();
        dataSource.setDataSourceName("jdbc:postgresql://localhost/weli");
        dataSource.setUser("weli");
        dataSource.setPassword("");

        System.out.println(dataSource.getConnection());

    }
}
</code></pre>
</div>

<p>The above code creates a <code class="highlighter-rouge">PGPoolingDataSource</code> class instance, and we set relative parameters for the class to connect to the database server. We use the <code class="highlighter-rouge">getConnection()</code> method of the <code class="highlighter-rouge">dataSource</code> to get the connection from the connection pool. Running the above code could get the following result:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Pooled connection wrapping physical connection org.postgresql.jdbc.PgConnection@497470ed
class com.sun.proxy.$Proxy0
</code></pre>
</div>

<p>From the above output, we can see a wrapper proxy instance around <code class="highlighter-rouge">org.postgresql.jdbc.PgConnection</code> being returned to the user.</p>

<p>From the users perspective, they don’t care about the implementation of the connection instance, they will just use it as an ordinary connection interface and call the methods to operate on the database.</p>

<p>If users call the <code class="highlighter-rouge">close</code> method of the connection, it will actually be returned to the connection pool instead of really being closed. This is implemented in the <code class="highlighter-rouge">org.postgresql.ds.PGPooledConnection</code> class.</p>

<p>Let’s check the class diagram of the <code class="highlighter-rouge">org.postgresql.ds.PGPooledConnection</code> in detail:</p>

<p><img src="/assets/jdbc/org.postgresql.ds.PGPooledConnection.png" alt="/assets/jdbc/org.postgresql.ds.PGPooledConnection.png" /></p>

<p>From the above diagram, we can see the connection instanced is proxied, and it is actually the inner class <code class="highlighter-rouge">ConnectionHandler</code> inside the <code class="highlighter-rouge">org.postgresql.jdbc.ds.PGPooledConnection</code> class.</p>

<p>Here is the debug process screenshot that proves the above conclusion:</p>

<p><img src="/assets/jdbc/pool_conn_proxy.png" alt="/assets/jdbc/pool_conn_proxy.png" /></p>

<p>From the above screenshot, you can see I have set the breakpoint at the <code class="highlighter-rouge">conn</code> instance returned from the data source. In the inspection window of IntelliJ IDEA, we can see the real class of the <code class="highlighter-rouge">conn</code> is <code class="highlighter-rouge">PGPooledConnection$ConnectionHandler</code>. Remember that <code class="highlighter-rouge">conn</code> has the type of <code class="highlighter-rouge">java.sql.Connection</code>, so the users will just treat it as ordinary connection to the database.</p>

<p>The job of <code class="highlighter-rouge">PGPooledConnection$ConnectionHandler</code> proxy is to dispatch the calls to the <code class="highlighter-rouge">org.postgresql.jdbc.PgConnection</code> that makes physical connections with the database server.</p>

<p><code class="highlighter-rouge">org.postgresql.jdbc.PgConnection</code> is the class that implements the <code class="highlighter-rouge">java.sql.Connection</code> interface, and it will make the physical connection with underlying database system.</p>

<p>The <code class="highlighter-rouge">org.postgresql.ds.PGPooledConnection$ConnectionHandler</code> proxy will handle the <code class="highlighter-rouge">org.postgresql.jdbc.PgConnection</code>. Now let’s check the code of the <code class="highlighter-rouge">org.postgresql.ds.PGPoolingDataSource</code> class to see how it manages the lifecycle of the physical connection.</p>

<p>Here is the code of <code class="highlighter-rouge">org.postgresql.ds.PGPooledConnection$ConnectionHandler</code> class:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="cm">/**
   * Instead of declaring a class implementing Connection, which would have to be updated for every
   * JDK rev, use a dynamic proxy to handle all calls through the Connection interface. This is the
   * part that requires JDK 1.3 or higher, though JDK 1.2 could be supported with a 3rd-party proxy
   * package.
   */</span>
  <span class="kd">private</span> <span class="kd">class</span> <span class="nc">ConnectionHandler</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Connection</span> <span class="n">con</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Connection</span> <span class="n">proxy</span><span class="o">;</span> <span class="c1">// the Connection the client is currently using, which is a proxy</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">automatic</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ConnectionHandler</span><span class="o">(</span><span class="n">Connection</span> <span class="n">con</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">con</span> <span class="o">=</span> <span class="n">con</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
      <span class="kd">final</span> <span class="n">String</span> <span class="n">methodName</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
      <span class="c1">// From Object</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getDeclaringClass</span><span class="o">()</span> <span class="o">==</span> <span class="n">Object</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">methodName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"toString"</span><span class="o">))</span> <span class="o">{</span>
          <span class="k">return</span> <span class="s">"Pooled connection wrapping physical connection "</span> <span class="o">+</span> <span class="n">con</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">methodName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"equals"</span><span class="o">))</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">proxy</span> <span class="o">==</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">methodName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"hashCode"</span><span class="o">))</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">System</span><span class="o">.</span><span class="na">identityHashCode</span><span class="o">(</span><span class="n">proxy</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">try</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">con</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InvocationTargetException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">throw</span> <span class="n">e</span><span class="o">.</span><span class="na">getTargetException</span><span class="o">();</span>
        <span class="o">}</span>
      <span class="o">}</span>

      <span class="c1">// All the rest is from the Connection or PGConnection interface</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">methodName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"isClosed"</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">con</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">con</span><span class="o">.</span><span class="na">isClosed</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">methodName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"close"</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// we are already closed and a double close</span>
        <span class="c1">// is not an error.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">con</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">SQLException</span> <span class="n">ex</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">con</span><span class="o">.</span><span class="na">isClosed</span><span class="o">())</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(!</span><span class="n">isXA</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">con</span><span class="o">.</span><span class="na">getAutoCommit</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
              <span class="n">con</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">ex</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="o">}</span>
          <span class="o">}</span>
          <span class="n">con</span><span class="o">.</span><span class="na">clearWarnings</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">con</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">proxy</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">last</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">fireConnectionClosed</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ex</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">con</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">con</span><span class="o">.</span><span class="na">isClosed</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">PSQLException</span><span class="o">(</span><span class="n">automatic</span>
            <span class="o">?</span> <span class="n">GT</span><span class="o">.</span><span class="na">tr</span><span class="o">(</span>
                <span class="s">"Connection has been closed automatically because a new connection was opened for the same PooledConnection or the PooledConnection has been closed."</span><span class="o">)</span>
            <span class="o">:</span> <span class="n">GT</span><span class="o">.</span><span class="na">tr</span><span class="o">(</span><span class="s">"Connection has been closed."</span><span class="o">),</span> <span class="n">PSQLState</span><span class="o">.</span><span class="na">CONNECTION_DOES_NOT_EXIST</span><span class="o">);</span>
      <span class="o">}</span>

      <span class="c1">// From here on in, we invoke via reflection, catch exceptions,</span>
      <span class="c1">// and check if they're fatal before rethrowing.</span>
      <span class="k">try</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">methodName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"createStatement"</span><span class="o">))</span> <span class="o">{</span>
          <span class="n">Statement</span> <span class="n">st</span> <span class="o">=</span> <span class="o">(</span><span class="n">Statement</span><span class="o">)</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">con</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
          <span class="k">return</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span>
              <span class="k">new</span> <span class="n">Class</span><span class="o">[]{</span><span class="n">Statement</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">org</span><span class="o">.</span><span class="na">postgresql</span><span class="o">.</span><span class="na">PGStatement</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
              <span class="k">new</span> <span class="nf">StatementHandler</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">st</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">methodName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"prepareCall"</span><span class="o">))</span> <span class="o">{</span>
          <span class="n">Statement</span> <span class="n">st</span> <span class="o">=</span> <span class="o">(</span><span class="n">Statement</span><span class="o">)</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">con</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
          <span class="k">return</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span>
              <span class="k">new</span> <span class="n">Class</span><span class="o">[]{</span><span class="n">CallableStatement</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">org</span><span class="o">.</span><span class="na">postgresql</span><span class="o">.</span><span class="na">PGStatement</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
              <span class="k">new</span> <span class="nf">StatementHandler</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">st</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">methodName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"prepareStatement"</span><span class="o">))</span> <span class="o">{</span>
          <span class="n">Statement</span> <span class="n">st</span> <span class="o">=</span> <span class="o">(</span><span class="n">Statement</span><span class="o">)</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">con</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
          <span class="k">return</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span>
              <span class="k">new</span> <span class="n">Class</span><span class="o">[]{</span><span class="n">PreparedStatement</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">org</span><span class="o">.</span><span class="na">postgresql</span><span class="o">.</span><span class="na">PGStatement</span><span class="o">.</span><span class="na">class</span><span class="o">},</span>
              <span class="k">new</span> <span class="nf">StatementHandler</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">st</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">con</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="kd">final</span> <span class="n">InvocationTargetException</span> <span class="n">ite</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Throwable</span> <span class="n">te</span> <span class="o">=</span> <span class="n">ite</span><span class="o">.</span><span class="na">getTargetException</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">te</span> <span class="k">instanceof</span> <span class="n">SQLException</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">fireConnectionError</span><span class="o">((</span><span class="n">SQLException</span><span class="o">)</span> <span class="n">te</span><span class="o">);</span> <span class="c1">// Tell listeners about exception if it's fatal</span>
        <span class="o">}</span>
        <span class="k">throw</span> <span class="n">te</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">Connection</span> <span class="nf">getProxy</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">proxy</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">setProxy</span><span class="o">(</span><span class="n">Connection</span> <span class="n">proxy</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">proxy</span> <span class="o">=</span> <span class="n">proxy</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">con</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">automatic</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="n">con</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="n">proxy</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="c1">// No close event fired here: see JDBC 2.0 Optional Package spec section 6.3</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isClosed</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">con</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre>
</div>

<p>From the above code, we can see the <code class="highlighter-rouge">invoke(...)</code> method in the <code class="highlighter-rouge">ConnectionHandler</code> wraps around the <code class="highlighter-rouge">Method</code> of <code class="highlighter-rouge">Connection</code>. For example, it handles the event like connection close. Here is the relative code:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">fireConnectionClosed</span><span class="o">();</span>
</code></pre>
</div>

<p>Now let’s check the code of this <code class="highlighter-rouge">fireConnectionClosed()</code> method:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="cm">/**
  * Used to fire a connection closed event to all listeners.
  */</span>
 <span class="kt">void</span> <span class="nf">fireConnectionClosed</span><span class="o">()</span> <span class="o">{</span>
   <span class="n">ConnectionEvent</span> <span class="n">evt</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
   <span class="c1">// Copy the listener list so the listener can remove itself during this method call</span>
   <span class="n">ConnectionEventListener</span><span class="o">[]</span> <span class="n">local</span> <span class="o">=</span>
       <span class="n">listeners</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="n">ConnectionEventListener</span><span class="o">[</span><span class="n">listeners</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
   <span class="k">for</span> <span class="o">(</span><span class="n">ConnectionEventListener</span> <span class="n">listener</span> <span class="o">:</span> <span class="n">local</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">evt</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">evt</span> <span class="o">=</span> <span class="n">createConnectionEvent</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
     <span class="o">}</span>
     <span class="n">listener</span><span class="o">.</span><span class="na">connectionClosed</span><span class="o">(</span><span class="n">evt</span><span class="o">);</span>
   <span class="o">}</span>
 <span class="o">}</span>
</code></pre>
</div>

<p>From the above code, we can see the <code class="highlighter-rouge">fireConnectionClosed()</code> method will create an instance of <code class="highlighter-rouge">ConnectionEvent</code> class and register it into an instance of <code class="highlighter-rouge">ConnectionEventListener</code>, and finally the listener will fire the <code class="highlighter-rouge">connectionClosed(...)</code> event.</p>

<p>The <code class="highlighter-rouge">ConnectionEvent</code> and <code class="highlighter-rouge">ConnectionEventListener</code> are two interfaces provided by the JDBC specification, and it is the container’s job to implement them properly to handle the event in a pooling environment. For example, in the <code class="highlighter-rouge">PGPoolingDataSource</code> demo datasource implementation, it will just return the connection back to its pool instead of really closing it. In the real container like Wildfly, it will rely on its pooling provider to manage the events (Apache Commons DBCP is a popular connection pooling provider used by many application servers). We will check the detail of the <code class="highlighter-rouge">PGPoolingDataSource</code> later in the article.</p>

<p>Now let’s see the class diagram of the <code class="highlighter-rouge">javax.sql.ConnectionEvent</code> and <code class="highlighter-rouge">javax.sql.ConnectionEventListener</code> interfaces:</p>

<p><img src="/assets/jdbc/events.png" alt="/assets/jdbc/pooling.png" /></p>

<p>From the above diagram, we can see the main job of the <code class="highlighter-rouge">ConnectionEventListener</code> interface is to handle the <code class="highlighter-rouge">connectionClosed(...)</code> method, and the <code class="highlighter-rouge">ConnectionEvent</code> will be passed in as the context. Now we need to check the implementation of the <code class="highlighter-rouge">PGPoolingDataSource</code> to see how to implement a pooling data source.</p>

<p><img src="/assets/jdbc/org.postgresql.dsPGPoolingDataSource.png" alt="/assets/jdbc/org.postgresql.dsPGPoolingDataSource.png" /></p>

<p>The above <code class="highlighter-rouge">org.postgresql.ds.PGPoolingDataSource</code> is a demo class that implements a simple data source pool. Firstly let’s check how does it stores connections in a “pool”. Here are the relative data structures in the class:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private Stack&lt;PooledConnection&gt; available = new Stack();
private Stack&lt;PooledConnection&gt; used = new Stack();
</code></pre>
</div>

<p>From the above code, we can see there are two stacks to store its “pooled” connections: one is named <code class="highlighter-rouge">available</code> and the other is called <code class="highlighter-rouge">used</code>. Besides the above two stacks, the <code class="highlighter-rouge">PGPoolingDataSource</code> class also stores a <code class="highlighter-rouge">PGConnectionPoolDataSource</code> instance:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private PGConnectionPoolDataSource source;
</code></pre>
</div>

<p>From the above code, we can see an instance of <code class="highlighter-rouge">PGConnectionPoolDataSource</code> that implements the <code class="highlighter-rouge">javax.sql.ConnectionPoolDataSource</code> interface is stored. Let’s now review the usages of <code class="highlighter-rouge">ConnectionPoolDataSource</code> interface: it defines a <code class="highlighter-rouge">getPooledConnection()</code> that will be used to return a <code class="highlighter-rouge">javax.sql.PooledConnection</code>, and the <code class="highlighter-rouge">javax.sql.PooledConnection</code> will return a managed <code class="highlighter-rouge">Connection</code> instance from the pool. In PostgreSQL driver, the <code class="highlighter-rouge">org.postgresql.ds.PGPooledConnection</code> implements the <code class="highlighter-rouge">javax.sql.PooledConnection</code> interface, and will return a <code class="highlighter-rouge">ConnectionHandler</code> proxy class that wraps around the physical <code class="highlighter-rouge">org.postgresql.jdbc.PgConnection</code> instance.</p>

<p>Next, the <code class="highlighter-rouge">ConnectionHandler</code> proxy will wrap the connection methods with event listener, and the event listener will be handled properly by the pooling vendor. Our pooling vendor is <code class="highlighter-rouge">PGPoolingDataSource</code>, which is a demo class to show how to implement a data source pool.</p>

<p>Now let’s go back to <code class="highlighter-rouge">PGPoolingDataSource</code> to see how it initializes the data source. Here is the <code class="highlighter-rouge">initialize()</code> method in the class:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>/**
 * Initializes this DataSource. If the initialConnections is greater than zero, that number of
 * connections will be created. After this method is called, the DataSource properties cannot be
 * changed. If you do not call this explicitly, it will be called the first time you get a
 * connection from the DataSource.
 *
 * @throws SQLException Occurs when the initialConnections is greater than zero, but the
 *         DataSource is not able to create enough physical connections.
 */
public void initialize() throws SQLException {
  synchronized (lock) {
    source = createConnectionPool();
    try {
      source.initializeFrom(this);
    } catch (Exception e) {
      throw new PSQLException(GT.tr("Failed to setup DataSource."), PSQLState.UNEXPECTED_ERROR,
          e);
    }

    while (available.size() &lt; initialConnections) {
      available.push(source.getPooledConnection());
    }

    initialized = true;
  }
}
</code></pre>
</div>

<p>The above code shows some important tasks that <code class="highlighter-rouge">initialize()</code> method will perform. Firstly, it will create a <code class="highlighter-rouge">PGConnectionPoolDataSource</code> instance. Here is the code:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>source = createConnectionPool();
</code></pre>
</div>

<p>The above code will create an instance of the <code class="highlighter-rouge">PGConnectionPoolDataSource</code>. The data source will be used to create some idle connections and pushed into the <code class="highlighter-rouge">available</code> stack. Here is the code:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>while (available.size() &lt; initialConnections) {
  available.push(source.getPooledConnection());
}
</code></pre>
</div>

<p>From the above code, we can see some connections are created initially and pushed to the <code class="highlighter-rouge">available</code> stack. This is a cache scheme for demonstration. Now we should check how does the connections are fetched from the stack. Here is the  <code class="highlighter-rouge">getPooledConnection()</code> method that takes the task:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private Connection getPooledConnection() throws SQLException {
    PooledConnection pc = null;
    Object var2 = this.lock;
    synchronized(this.lock) {
        if(this.available == null) {
            throw new PSQLException(GT.tr("DataSource has been closed.", new Object[0]), PSQLState.CONNECTION_DOES_NOT_EXIST);
        }

        while(true) {
            if(!this.available.isEmpty()) {
                pc = (PooledConnection)this.available.pop();
                this.used.push(pc);
                break;
            } else if(this.maxConnections != 0 &amp;&amp; this.used.size() &gt;= this.maxConnections) {
                try {
                    this.lock.wait(1000L);
                } catch (InterruptedException var5) {
                    ;
                }
            } else {
                pc = this.source.getPooledConnection();
                this.used.push(pc);
                break;
            }
        }
    }

    pc.addConnectionEventListener(this.connectionEventListener);
    return pc.getConnection();
}
</code></pre>
</div>

<p>The above method shows us how does a connection fetched from the stack. Here is the relative part of the code:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>pc = (PooledConnection)this.available.pop();
this.used.push(pc);
</code></pre>
</div>

<p>From the above code we can see there will be a connection poped from the <code class="highlighter-rouge">available</code> stack, and it will be pushed it into the <code class="highlighter-rouge">used</code> stack. Finally the connection will be returned to the caller. If <code class="highlighter-rouge">maxConnections</code> are reached, it means there is no usable connection in the <code class="highlighter-rouge">available</code> stack. In this condition, the process will wait for for 1 second for the available connections to be returned back to the stack and try again:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>else if(this.maxConnections != 0 &amp;&amp; this.used.size() &gt;= this.maxConnections) {
...
this.lock.wait(1000L);
...
}
</code></pre>
</div>

<p>The above logic is very low efficient, that’s why this <code class="highlighter-rouge">PGPoolingDataSource</code> class is just for demonstration and can’t be used in production field. In application server, we’ll have more powerful connection pool solutions.</p>

<p>Now let’s go on our code reading. If the number of connections in the <code class="highlighter-rouge">available</code> stack does not meet the <code class="highlighter-rouge">maxConnections</code>, it will create a new connection from the data source and immediately pushed into <code class="highlighter-rouge">used</code> stack:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>...
pc = this.source.getPooledConnection();
this.used.push(pc);
...

</code></pre>
</div>

<p>The above code shows the new connection is created and pushed into the <code class="highlighter-rouge">used</code> stack. Now we know if the connection is being used by a thread, it will be kept into the <code class="highlighter-rouge">used</code> stack.</p>

<p>Now let’s think about this question: how does the connection moved from <code class="highlighter-rouge">used</code> stack back to <code class="highlighter-rouge">available</code> stack? The answer is: this is achieved by the listener pattern. In <code class="highlighter-rouge">getPooledConnection()</code> method, we can see a event listener is added to the pooled connection. The code is like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>pc.addConnectionEventListener(this.connectionEventListener);
</code></pre>
</div>

<p>From the above code, we can see the <code class="highlighter-rouge">connectionEventListerner</code> instance is added into the <code class="highlighter-rouge">PooledConnection pc</code> instance. The connection listener will finally be called with its <code class="highlighter-rouge">connectionClosed(...)</code> method, and the method is actually implemented by the pooling provider. So it is job of the <code class="highlighter-rouge">PGPoolingDataSource</code> demo class to implement the logic itself. Here is how the <code class="highlighter-rouge">ConnectionEventListener</code> inner class in <code class="highlighter-rouge">PGPoolingDataSource</code> class that implements it for demonstration purpose:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>/**
 * Notified when a pooled connection is closed, or a fatal error occurs on a pooled connection.
 * This is the only way connections are marked as unused.
 */
private ConnectionEventListener connectionEventListener = new ConnectionEventListener() {
  public void connectionClosed(ConnectionEvent event) {
    ((PooledConnection) event.getSource()).removeConnectionEventListener(this);
    synchronized (lock) {
      if (available == null) {
        return; // DataSource has been closed
      }
      boolean removed = used.remove(event.getSource());
      if (removed) {
        available.push((PooledConnection) event.getSource());
        // There's now a new connection available
        lock.notify();
      } else {
        // a connection error occurred
      }
    }
  }

  /**
   * This is only called for fatal errors, where the physical connection is useless afterward and
   * should be removed from the pool.
   */
  public void connectionErrorOccurred(ConnectionEvent event) {
    ((PooledConnection) event.getSource()).removeConnectionEventListener(this);
    synchronized (lock) {
      if (available == null) {
        return; // DataSource has been closed
      }
      used.remove(event.getSource());
      // We're now at least 1 connection under the max
      lock.notify();
    }
  }
};
</code></pre>
</div>

<p>From the above code, we can see that when a pooled connection is closed, it will be returned back to the <code class="highlighter-rouge">available</code> pool and removed from <code class="highlighter-rouge">used</code> pool. The connection won’t be really closed actually.</p>

<p>Now let’s see how does <code class="highlighter-rouge">org.postgresql.ds.PGPooledConnection</code> class call the above implemented listener. Here is the code:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private final List&lt;ConnectionEventListener&gt; listeners = new LinkedList&lt;ConnectionEventListener&gt;();
...
/**
 * Adds a listener for close or fatal error events on the connection handed out to a client.
 */
public void addConnectionEventListener(ConnectionEventListener connectionEventListener) {
  listeners.add(connectionEventListener);
}

/**
 * Removes a listener for close or fatal error events on the connection handed out to a client.
 */
public void removeConnectionEventListener(ConnectionEventListener connectionEventListener) {
  listeners.remove(connectionEventListener);
}
...
/**
 * Used to fire a connection closed event to all listeners.
 */
void fireConnectionClosed() {
  ConnectionEvent evt = null;
  // Copy the listener list so the listener can remove itself during this method call
  ConnectionEventListener[] local =
      listeners.toArray(new ConnectionEventListener[listeners.size()]);
  for (ConnectionEventListener listener : local) {
    if (evt == null) {
      evt = createConnectionEvent(null);
    }
    listener.connectionClosed(evt);
  }
}

/**
 * Used to fire a connection error event to all listeners.
 */
void fireConnectionFatalError(SQLException e) {
  ConnectionEvent evt = null;
  // Copy the listener list so the listener can remove itself during this method call
  ConnectionEventListener[] local =
      listeners.toArray(new ConnectionEventListener[listeners.size()]);
  for (ConnectionEventListener listener : local) {
    if (evt == null) {
      evt = createConnectionEvent(e);
    }
    listener.connectionErrorOccurred(evt);
  }
}
...
</code></pre>
</div>

<p>From the above code, we can see the listeners are stored in <code class="highlighter-rouge">listeners</code> linked list. These methods will be called in the inner class <code class="highlighter-rouge">ConnectionHandler</code>, which is the proxy class represents the connection as we have seen. We can see the <code class="highlighter-rouge">fireConnectionClosed()</code> is called when the user invoke the <code class="highlighter-rouge">close()</code> method of the connection.</p>

<p>From user’s perspective, they don’t need to care about these underlying implementations, and they just use the connection interface as common to interact with the underlying database. From the database manager’s perspective, they can change or tune the data pooling provider in the application server level. In our example, we use a very simple data pooling provider named <code class="highlighter-rouge">PGPoolingDataSource</code>. We even don’t have to implement a pool at all and just provide a single connection to the users. For example, there is a ‘PGSimpleDataSource’ class provided by PostgreSQL driver that will not provide any ‘pooling’, and it will just pass every connection request to the underlying physical connections. Here is the code of the class:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kn">package</span> <span class="n">org</span><span class="o">.</span><span class="na">postgresql</span><span class="o">.</span><span class="na">ds</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.postgresql.ds.common.BaseDataSource</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.Serializable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.sql.SQLException</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.sql.DataSource</span><span class="o">;</span>

<span class="cm">/**
 * Simple DataSource which does not perform connection pooling. In order to use the DataSource, you
 * must set the property databaseName. The settings for serverName, portNumber, user, and password
 * are optional. Note: these properties are declared in the superclass.
 *
 * @author Aaron Mulder (ammulder@chariotsolutions.com)
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PGSimpleDataSource</span> <span class="kd">extends</span> <span class="n">BaseDataSource</span> <span class="kd">implements</span> <span class="n">DataSource</span><span class="o">,</span> <span class="n">Serializable</span> <span class="o">{</span>
<span class="o">...</span>
<span class="o">}</span>
</code></pre>
</div>

<p>From the above code, we can see the <code class="highlighter-rouge">PGSimpleDataSource</code> is just a thin layer that didn’t provide any data source pool inside. In this article, I have showed you the JDBC connection pool design, and we have checked a demo implementation of the architecture. We can see the whole design is very flexible, it decouples three kind of people: the user of the data base, the data base driver developer, the connection pool provider. We haven’t checked the real connection pool provider in an application server. For example, Wildfly uses Apache Commons DBCP as its connection pool provider.</p>

<p>I plan to write article to introduce the data source in Wildfly, but it will be out of the scope of this series of the articles. In the next article, I’d like to introduce the transaction aspect of the JDBC specification.</p>
