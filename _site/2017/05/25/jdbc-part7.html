<p>In the previous article, we have learned how to add a JDBC database driver module into Wildfly, and how to configure a datasource to use hte driver. In this article, let’s see the JDBC driver loading process in Wildfly.</p>

<p>In Wildfly source code (See <a href="https://github.com/wildfly/wildfly">https://github.com/wildfly/wildfly</a>), the <code class="highlighter-rouge">connector</code> module contains the <code class="highlighter-rouge">datasources</code> subsystem. Here is the screenshot of the source code structure of <code class="highlighter-rouge">wildfly</code>:</p>

<p><img src="/assets/jdbc/datasources.png" alt="/assets/jdbc/datasources.png" /></p>

<p>The above screenshot shows the <code class="highlighter-rouge">datasources</code> subsystem. In the subsystem, we can find the <code class="highlighter-rouge">org.jboss.as.connector.subsystems.datasources.JdbcDriverAdd</code> class, and here is its class diagram:</p>

<p><img src="/assets/jdbc/JdbcDriverAdd.png" alt="/assets/jdbc/JdbcDriverAdd.png" /></p>

<p>The above diagram shows the methods in <code class="highlighter-rouge">JdbcDriverAdd</code> class. Firstly we need to check the <code class="highlighter-rouge">performRuntime(...)</code> method. Here is the sequence diagram of the method:</p>

<p><img src="/assets/jdbc/org.jboss.as.connector.subsystems.datasources.JdbcDriverAdd.performRuntime(OperationContext, ModelNode, ModelNode).png" alt="/assets/jdbc/org.jboss.as.connector.subsystems.datasources.JdbcDriverAdd.performRuntime(OperationContext, ModelNode, ModelNode).png" /></p>

<p>From the above diagram, we can find out two things: Firstly the method will try to fetch multiple values defined by the users. For example, there are <code class="highlighter-rouge">DRIVER_CLASS_NAME</code> and <code class="highlighter-rouge">DRIVER_XA_DATASOURCE_CLASS_NAME</code> that users can set in the server configuration file.</p>

<p>Another thing we can see from the above diagram is that the method will try to find the JDBC driver class automatically if <code class="highlighter-rouge">driverClass</code> is null, and it will invoke the <code class="highlighter-rouge">loadService(Driver.class)</code> method for this task.</p>

<p>Let check the above notes one by one. First let’s see the origin class of the <code class="highlighter-rouge">DRIVER_CLASS_NAME</code> and <code class="highlighter-rouge">DRIVER_XA_DATASOURCE_CLASS_NAME</code> constants. They are defined in the <code class="highlighter-rouge">org.jboss.as.connector.subsystems.datasources.Constants</code> class, and here is its class diagram:</p>

<p><img src="/assets/jdbc/Constants.png" alt="/assets/jdbc/Constants.png" /></p>

<p>The above diagram just show part of the whole class because it is too big. You can check the code directly to get all the constants defined in the class. These constants can mostly be defined in the server configuration file. For example, we can see the string value of <code class="highlighter-rouge">DATASOURCE_DRIVER_CLASS_NAME</code> is <code class="highlighter-rouge">driver-class</code>. Actually we can configure this in the <code class="highlighter-rouge">standalone/configuration/standalone.xml</code>:</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">"postgresql"</span> <span class="na">module=</span><span class="s">"org.postgresql"</span><span class="nt">&gt;</span>
	<span class="nt">&lt;driver-class&gt;</span>org.postgresql.Driver<span class="nt">&lt;/driver-class&gt;</span>
<span class="nt">&lt;/driver&gt;</span>				
</code></pre>
</div>

<p>But in the last article, we didn’t configure the <code class="highlighter-rouge">driver-class</code>, but Wildfly can still load the driver class correctly. This is because the <code class="highlighter-rouge">loadService(...)</code> method will help us to find the driver class in the module. Here is the relative code in the method:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code> <span class="k">if</span> <span class="o">(</span><span class="n">driverClassName</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">ServiceLoader</span><span class="o">&lt;</span><span class="n">Driver</span><span class="o">&gt;</span> <span class="n">serviceLoader</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="na">loadService</span><span class="o">(</span><span class="n">Driver</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="kt">boolean</span> <span class="n">driverLoaded</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">serviceLoader</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="n">Driver</span> <span class="n">driver</span> <span class="o">:</span> <span class="n">serviceLoader</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">startDriverServices</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">moduleId</span><span class="o">,</span> <span class="n">driver</span><span class="o">,</span> <span class="n">driverName</span><span class="o">,</span> <span class="n">majorVersion</span><span class="o">,</span> <span class="n">minorVersion</span><span class="o">,</span> <span class="n">dataSourceClassName</span><span class="o">,</span> <span class="n">xaDataSourceClassName</span><span class="o">);</span>
                    <span class="n">driverLoaded</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="c1">//just consider first definition and create service for this. User can use different implementation only</span>
                    <span class="c1">// w/ explicit declaration of driver-class attribute</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
<span class="o">...</span>
</code></pre>
</div>

<p>From the above code, we can see the <code class="highlighter-rouge">module.loadService(Driver.class)</code> method will try to find the class that implements the <code class="highlighter-rouge">Driver.class</code> interface from the module. If it finds the driver classes, it will install them one by one by using the <code class="highlighter-rouge">startDriverServices(...)</code> method.</p>

<p>To verify our analysis, we can set a breakpoint in <code class="highlighter-rouge">JdbcDriverAdd</code> class. To understand how to debug the Wildfly startup process, you need to read these two articles firstly:</p>

<ul>
  <li><a href="http://wildflyinternals.io/2017/05/05/wildfly-src.html">Fetching and compiling the Wildfly upstream source</a></li>
  <li><a href="http://wildflyinternals.io/2017/05/07/troubleshooting-wildfly.html">Troubleshooting the Wildfly startup process</a></li>
</ul>

<p>I have introduced the techniques to debug the Wildfly server. I used the methods introduced in above articles to catch the startup process by setting the breakpoint in <code class="highlighter-rouge">JdbcDriverAdd</code> class, and then start the Wildfly server in debug mode. Here is what I get in my IntelliJ IDEA environment:</p>

<p><img src="/assets/jdbc/JdbcDriverAdd-debug.png" alt="/assets/jdbc/JdbcDriverAdd-debug.png" /></p>

<p>The above screenshot shows that during the Wildfly server startup process, it will use the <code class="highlighter-rouge">JdbcDriverAdd</code> to load the drivers defined in configuration file. Because we didn’t define the <code class="highlighter-rouge">driver-class</code> in <code class="highlighter-rouge">standalone.xml</code>, so it goes into the logic to find the driver class automatically.</p>

<p>Now I step the code to the <code class="highlighter-rouge">startDriverServices(...)</code> method, and here is the screenshot:</p>

<p><img src="/assets/jdbc/JdbcDriverAdd-debug2.png" alt="/assets/jdbc/JdbcDriverAdd-debug2.png" /></p>

<p>From the above screenshot, we can see Wildfly has found the PostgreSQL JDBC driver, which is <code class="highlighter-rouge">org.postgresql.Driver</code>.</p>

<p>Now let’s go a little big deeper into the <code class="highlighter-rouge">startDriverServices(...)</code> method. I stepped into the method and here is the screenshot:</p>

<p><img src="/assets/jdbc/JdbcDriverAdd-debug3.png" alt="/assets/jdbc/JdbcDriverAdd-debug3.png" /></p>

<p>From the above screenshot, we can see that Wildfly will create a <code class="highlighter-rouge">DriverService</code> for the driver and install it into its micro container. I won’t dive into deeper details in this article, but you may want to learn about the micro container design of Wildfly. If so, you can read these articles:</p>

<ul>
  <li><a href="http://wildflyinternals.io/2017/05/10/jboss-msc.html">An introduction to the JBoss Modular Service Container: Part 1 - Basic architecture of the container</a></li>
  <li><a href="http://wildflyinternals.io/2017/05/21/jboss-msc2.html">DRAFT - An introduction to the JBoss Modular Service Container: Part 2 - Transaction layer</a></li>
</ul>

<p>The above articles will give you an introduction to the Wildfly micro container design.</p>

<p>In this article, we have checked how does Wildfly load the JDBC driver. In next article, I will introduce the Wildfly datasource loading process.</p>

