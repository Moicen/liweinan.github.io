---
title: RESTEasy Implementation of JAX-RS SPEC 2.0 Section 3.7 - DRAFT
abstract: In this article I'd like to share with you my study on JAX-RS SPEC 2.0 Section 3.7 and relative implementations in RESTEasy.
---

## _{{ page.title }}_

{{ page.abstract }}

_JAX-RS SPEC 2.0 Section 3.7_[^spec](abbreviated as [spec3.7] in this article) shows us how to match a URI path to actual Java method:

[^spec]: [JSR-000339 The JavaTM API for RESTful Web Services](https://jcp.org/aboutJava/communityprocess/final/jsr339/index.html)

> 1. Identify a set of candidate root resource classes matching the request
> 2. Obtain a set of candidate resource methods for the request
> 3. Identify the method that will handle the request

To implement the above logic, RESTEasy has provided several classes in package `org.jboss.resteasy.registry`, and here are the classes:

![RESTEasy classes]({{ site.url }}/assets/spec3.7.png)

From the above class diagram, we can see some relationships about these classes. Firstly, there are four `Node` classes, which are `RootClassNode`, `ClassNode`, `RootNode` and `SegmentNode`. Secondly, there one `Expression` interface and its two implementations, which are `ClassExpression` and `MethodExpression`.

From the class name, we can deduce that the `Expression` classes must contain information for matching the URI path. The `ClassExpression` class should be used to match classes, and the `MethodExpression` should be used to match methods.

For the `Node` classes, we can see `RootClassNode` is only connected with `ClassNode`, as its `root` attribute. From the name of the class, we can deduce that `RootClassNode` is the top data structure in matching process. We can verify this deduction later.

Next we should check `ClassNode`. We can see `ClassNode` is connected with `ClassExpression` bidirectionally. `ClassNode` contains `targets` field, which has the type `ArrayList<ClassExpression>`. In another direction, `ClassExpression` has a `parent` field, and the type of the field is `ClassNode`.

`ClassExpression` also contains a `root` field, which has a type of `RootNode`. `RootNode` also contains a `root` field, which type is `SegmentNode`.

Now we can check `SegmentNode`. This class has a bidirectional relationship with `MethodExpression`, which is simliar to the relationship between `ClassNode` and `ClassExpression`. From this, we can deduce that the `SegmentNode` will be used to deal with the method matching process.

From the above analyze, we can see a relationship between these classes like this:

```
RootClassNode -> ClassNode <-> ClassExpression -> RootNode -> SegmentNode <-> MethodExpression
```

So the whole matching process should start from `RootClassNode`. We can verify our deduction by analyzing the real codes in RESTEasy.

In following sections, I will explain the above classes in detail. Firstly, we need to learn about the core classes in `org.jboss.resteasy.registry`. I have done this work, and I can say that the entry point of the matching process is `ResourceMethodRegistry.getResourceInvoker` method call. Here is the sequence diagram of the method call:

![org.jboss.resteasy.core.ResourceMethodRegistry.getResourceInvoker.png]({{ site.url }}/assets/org.jboss.resteasy.core.ResourceMethodRegistry.getResourceInvoker.png)

The above diagram reflects the following codes in `ResourceMethodRegistry` class:

```java
public ResourceInvoker getResourceInvoker(HttpRequest request)
{
   try
   {
      if (widerMatching) return rootNode.match(request, 0);
      else return root.match(request, 0);
   }
   catch (RuntimeException e)
   {
      throw e;
   }
}
```

We can see that `rootNode : RootNode` and `root : RootClassNode` are used in two different conditions, and the `widerMatching` variable controls the above logic.

---

The matching process implemented in RESTEasy is shown in following sequence diagram:

![org.jboss.resteasy.core.registry.RootClassNode.match.png]({{ site.url }}/assets/org.jboss.resteasy.core.registry.RootClassNode.match.png)

From the above diagram, we can see the URL matching process starts from the `RootClassNode`. Inside the `RootClassNode` it contains a `ClassNode` instance named `root`, and `RootClassNode` will call the `match` method of `root`.

The method returns a `RootNode` instance, which also has a `match` method, and `RootClassNode` will then call the `match` method of `RootNode`.

From the sequence diagram shown above, we can see how the two `match` methods in `ClassNode` and `RootNode` are chained together in the calling process inside `RootClassNode`. Here is the source code in `RootClassNode` for above sequence:

```java
public ResourceInvoker match(HttpRequest request, int start)
{
   return root.match(request, start).match(request, start);
}
```

From the above code, we can see the matching process will finally return a `ResourceInvoker`, which encapsulates the chosen method that serves the _URI_ request.



### _References_

---
