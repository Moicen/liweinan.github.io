---
title: RESTEasy Implementation of JAX-RS SPEC 2.0 Section 3.7 - DRAFT
abstract: In this article I'd like to share with you my study on JAX-RS SPEC 2.0 Section 3.7 and relative implementations in RESTEasy.
---

## _{{ page.title }}_

{{ page.abstract }}

_JAX-RS SPEC 2.0 Section 3.7_[^spec] shows us how to match a URI path to actual Java method:

[^spec]: [JSR-000339 The JavaTM API for RESTful Web Services](https://jcp.org/aboutJava/communityprocess/final/jsr339/index.html)

> 1. Identify a set of candidate root resource classes matching the request
> 2. Obtain a set of candidate resource methods for the request
> 3. Identify the method that will handle the request

Here's the classes that RESTEasy used to implement the algorithm:

![RESTEasy classes]({{ site.url }}/assets/spec3.7.png)

We can see many relationships from above picture: `Match` contains a `MethodExpression` and a `Matcher`. `Matcher` is default Java regexp engine class.

`MethodExpression` contains `parent : SegmentNode` and `invoker : ResourceInvoker`. It also contains a method `compareTo(expression : Expression)`. So `MethodExpression` maps a `SegmentNode` to a `ResourceInvoker`.

`Expression` class contains a `regex : String` and `pattern : Pattern`. The `Pattern` class is a standard Java regex class, compiled from `regex`. `Expression` class also contains a `groups : List<Group>` field, which stores path segment groups. `Expression` class contains a default pattern:

---

The matching process implemented in RESTEasy is shown in following sequence diagram:

![org.jboss.resteasy.core.registry.RootClassNode.match.png]({{ site.url }}/assets/org.jboss.resteasy.core.registry.RootClassNode.match.png)

From the above diagram, we can see the URL matching process starts from the `RootClassNode`. Inside the `RootClassNode` it contains a `ClassNode` instance named `root`, and `RootClassNode` will call the `match` method of `root`.

The method returns a `RootNode` instance, which also has a `match` method, and `RootClassNode` will then call the `match` method of `RootNode`.

From the sequence diagram shown above, we can see how the two `match` methods in `ClassNode` and `RootNode` are chained together in the calling process inside `RootClassNode`. Here is the source code in `RootClassNode` for above sequence:

```java
public ResourceInvoker match(HttpRequest request, int start)
{
   return root.match(request, start).match(request, start);
}
```

From the above code, we can see the matching process will finally return a `ResourceInvoker`, which encapsulates the chosen method that serves the _URI_ request.

---

The following diagram shows the process of `ResourceMethodRegistry.getResourceInvoker` method call:

![org.jboss.resteasy.core.ResourceMethodRegistry.getResourceInvoker.png]({{ site.url }}/assets/org.jboss.resteasy.core.ResourceMethodRegistry.getResourceInvoker.png)

Here is the relative codes in `ResourceMethodRegistry` class:

```java
public ResourceInvoker getResourceInvoker(HttpRequest request)
{
   try
   {
      if (widerMatching) return rootNode.match(request, 0);
      else return root.match(request, 0);
   }
   catch (RuntimeException e)
   {
      throw e;
   }
}
```

We can see the usage of `RootNode` and `RootClassNode` in two different conditions. The `widerMatching` variable controls the above logic.

---

Here is the relationship between `ClassNode`, `RootClassNode`, `RootNode` and `SegmentNode` and other two relative classes:

![2017-03-07-matching-nodes.png]({{ site.url }}/assets/2017-03-07-matching-nodes.png)


_References_

---
