---
title: RESTEasy Implementation of JAX-RS SPEC 2.0 Section 3.7 - DRAFT
abstract: In this article I'd like to share with you my study on JAX-RS SPEC 2.0 Section 3.7 and relative implementations in RESTEasy.
---

## _{{ page.title }}_

{{ page.abstract }}

_JAX-RS SPEC 2.0_[^spec] shows us how to match a URI path to actual Java method in _Section 3.7_:

[^spec]: "JSR-000339 The Javatm API For Restful Web Services". 2017. Jcp.Org. [https://jcp.org/aboutJava/communityprocess/final/jsr339/index.html.](https://jcp.org/aboutJava/communityprocess/final/jsr339/index.html.)

> 1. Identify a set of candidate root resource classes matching the request
> 2. Obtain a set of candidate resource methods for the request
> 3. Identify the method that will handle the request

To implement the above logic, RESTEasy has provided several classes in package `org.jboss.resteasy.registry`, and here are the classes:

![RESTEasy classes]({{ site.url }}/assets/spec3.7.png)

From the above class diagram, we can see some relationships about these classes. Firstly, there are four `Node` classes, which are `RootClassNode`, `ClassNode`, `RootNode` and `SegmentNode`. Secondly, there one `Expression` interface and its two implementations, which are `ClassExpression` and `MethodExpression`.

From the class name, we can deduce that the `Expression` classes must contain information for matching the URI path. The `ClassExpression` class should be used to match classes, and the `MethodExpression` should be used to match methods.

For the `Node` classes, we can see `RootClassNode` is only connected with `ClassNode`, as its `root` attribute. From the name of the class, we can deduce that `RootClassNode` is the top data structure in matching process. We can verify this deduction later.

Next we should check `ClassNode`. We can see `ClassNode` is connected with `ClassExpression` bidirectionally. `ClassNode` contains `targets` field, which has the type `ArrayList<ClassExpression>`. In another direction, `ClassExpression` has a `parent` field, and the type of the field is `ClassNode`. So this is a _One-To-Many_ relationship: one `ClassNode` instance contains many `ClassExpression` instances.

We need to examine `ClassExpression` now. `ClassExpression` also contains a `root` field, which has a type of `RootNode`. `RootNode` contains a `root` field too, which type is `SegmentNode`.

Now we can check `SegmentNode`. This class has a bidirectional relationship with `MethodExpression`, which is simliar to the relationship between `ClassNode` and `ClassExpression`.

From the above analyze, we can deduce that `RootNode` and `SegmentNode` are two abstract concepts that connects the class matching and method matching processes. The relationship between these classes is like this:

```
RootClassNode -> ClassNode <-> ClassExpression -> RootNode -> SegmentNode <-> MethodExpression
```

So the whole matching process should start from `RootClassNode`. We can verify our deduction by analyzing the real codes in RESTEasy. I have done this work, and I can say that the entry point of the matching process is `ResourceMethodRegistry.getResourceInvoker` method call. Here is the sequence diagram of the method call:

![org.jboss.resteasy.core.ResourceMethodRegistry.getResourceInvoker.png]({{ site.url }}/assets/org.jboss.resteasy.core.ResourceMethodRegistry.getResourceInvoker.png)

The above diagram reflects the following codes in `ResourceMethodRegistry.getResourceInvoker` method call:

```java
public ResourceInvoker getResourceInvoker(HttpRequest request)
{
   try
   {
      if (widerMatching) return rootNode.match(request, 0);
      else return root.match(request, 0);
   }
   catch (RuntimeException e)
   {
      throw e;
   }
}
```

We can see that `rootNode : RootNode` and `root : RootClassNode` are used in two different conditions, and the `widerMatching` variable controls the above logic.

The `widerMatching` variable is defined by `ResteasyDeployment` class. In `ResteasyDeployment` class it contains a variable called `widerRequestMatching`:

```java
public class ResteasyDeployment
{
   protected boolean widerRequestMatching;
}
```

And it is set by user controlled `Configuration Switches`[^switch]:

[^switch]: "RESTFul Web Services for Java - Chapter 3. Installation/Configuration - 3.4. Configuration switches". 2017. Docs.Jboss.Org. [https://docs.jboss.org/resteasy/docs/3.1.0.Final/userguide/html/Installation_Configuration.html.](https://docs.jboss.org/resteasy/docs/3.1.0.Final/userguide/html/Installation_Configuration.html.)

![2017-03-10-switch.png]({{ site.url }}/assets/2017-03-10-switch.png)

From the above screenshot of RESTEasy document, we can see the meaning of ` resteasy.wider.request.matching` switch:

> Turns off the JAX-RS spec defined class-level expression filtering and instead tries to match version every method's full path.

From the above descrption, we can see the switch is to override some _SPEC_ defined behaviors, and the default value is `false`. In this article I'll focus on analyzing the _SPEC_ defined behavior, so I will ignore the logic:

```java
if (widerMatching) return rootNode.match(request, 0);
```

And treat this as the matching logic entry point:

```java
else return root.match(request, 0);
```

Now let's check the `Node` classes. For all the `Node` classes, there are `match()` method inside. Let's check these methods one by one. First is the `match` method of `RootClassNode`:

![org.jboss.resteasy.core.registry.RootClassNode.match.png]({{ site.url }}/assets/org.jboss.resteasy.core.registry.RootClassNode.match.png)

From above diagram, we can see the call chain like this: `RootClassNode.match() -> ClassNode.match() -> RootNode.match()`. Now let's check the `match` method of `ClassNode`:

![org.jboss.resteasy.core.registry.ClassNode.match.png]({{ site.url }}/assets/org.jboss.resteasy.core.registry.ClassNode.match.png)

From above digram, we can see the `ClassNode -> RootNode` matching process is complex, and it uses the `ClassExpression` in matching process. We'll check the detail later. Now we should check `RootNode.match()`:

![org.jboss.resteasy.core.registry.RootNode.match.png]({{ site.url }}/assets/org.jboss.resteasy.core.registry.RootNode.match.png)

We can see `RootNode -> SegmentNode` is easy, because `RootNode.match()` will just call `SegmentNode.match()`. Let's check the sequence diagram of `SegmentNode.match()`:

![org.jboss.resteasy.core.registry.SegmentNode.match.png]({{ site.url }}/assets/org.jboss.resteasy.core.registry.SegmentNode.match.png)

From the above diagram, we can see `SegmentNode` matching process is simliar to the `ClassNode` matching process, however the `MethodExpression` class is used instead of the `ClassExpression`.

In conclusion, the matching processes are mainly in `ClassNode` and `SegmentNode`. `ClassNode` deals with class matching process, and `SegmentNode` processes the method matching process.

Now let's go back to _SPEC_ document and learn the terminology defined in _Section 1.5_:

![2017-03-10-terminology.png]({{ site.url }}/assets/2017-03-10-terminology.png)

From the above definitions, we need to understand the definitions of `Resource class`, `Root resource class`, `Sub-resource locator` and `Sub-resource method`, because these terms will be frequently addressed in matching process described in _Section 3.7_ of the _SPEC_.


### _References_

---
