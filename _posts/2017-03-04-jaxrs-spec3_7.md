---
title: RESTEasy Implementation of JAX-RS SPEC 2.0 Section 3.7 - DRAFT
abstract: In this article I'd like to share with you my study on JAX-RS SPEC 2.0 Section 3.7 and relative implementations in RESTEasy.
---

## _{{ page.title }}_

{{ page.abstract }}

_JAX-RS SPEC 2.0 Section 3.7_[^spec](abbreviated as [spec3.7] in this article) shows us how to match a URI path to actual Java method:

[^spec]: [JSR-000339 The JavaTM API for RESTful Web Services](https://jcp.org/aboutJava/communityprocess/final/jsr339/index.html)

> 1. Identify a set of candidate root resource classes matching the request
> 2. Obtain a set of candidate resource methods for the request
> 3. Identify the method that will handle the request

To implement the above logic, RESTEasy has provided several classes in package `org.jboss.resteasy.registry`, and here are the classes:

![RESTEasy classes]({{ site.url }}/assets/spec3.7.png)

From the above class diagram, we can see some relationships about these classes. Firstly, there are four `Node` classes, which are `RootClassNode`, `ClassNode`, `RootNode` and `SegmentNode`. Secondly, there one `Expression` interface and its two implementations, which are `ClassExpression` and `MethodExpression`.

From the class name, we can deduce that the `Expression` classes must contain information for matching the URI path. The `ClassExpression` class should be used to match classes, and the `MethodExpression` should be used to match methods.

For the `Node` classes, we can see `RootClassNode` is only connected with `ClassNode`, as its `root` attribute. From the name of the class, we can deduce that `RootClassNode` is the top data structure in matching process. We can verify this deduction later.

Next we should check `ClassNode`. We can see `ClassNode` is connected with `ClassExpression` bidirectionally. `ClassNode` contains `targets` field, which has the type `ArrayList<ClassExpression>`. In another direction, `ClassExpression` has a `parent` field, and the type of the field is `ClassNode`. So this is a _One-To-Many_ relationship: one `ClassNode` instance contains many `ClassExpression` instances.

We need to examine `ClassExpression` now. `ClassExpression` also contains a `root` field, which has a type of `RootNode`. `RootNode` contains a `root` field too, which type is `SegmentNode`.

Now we can check `SegmentNode`. This class has a bidirectional relationship with `MethodExpression`, which is simliar to the relationship between `ClassNode` and `ClassExpression`.

From the above analyze, we can deduce that `RootNode` and `SegmentNode` are two abstract concepts that connects the class matching and method matching processes. The relationship between these classes is like this:

```
RootClassNode -> ClassNode <-> ClassExpression -> RootNode -> SegmentNode <-> MethodExpression
```

So the whole matching process should start from `RootClassNode`. We can verify our deduction by analyzing the real codes in RESTEasy. I have done this work, and I can say that the entry point of the matching process is `ResourceMethodRegistry.getResourceInvoker` method call. Here is the sequence diagram of the method call:

![org.jboss.resteasy.core.ResourceMethodRegistry.getResourceInvoker.png]({{ site.url }}/assets/org.jboss.resteasy.core.ResourceMethodRegistry.getResourceInvoker.png)

The above diagram reflects the following codes in `ResourceMethodRegistry.getResourceInvoker` method call:

```java
public ResourceInvoker getResourceInvoker(HttpRequest request)
{
   try
   {
      if (widerMatching) return rootNode.match(request, 0);
      else return root.match(request, 0);
   }
   catch (RuntimeException e)
   {
      throw e;
   }
}
```

We can see that `rootNode : RootNode` and `root : RootClassNode` are used in two different conditions, and the `widerMatching` variable controls the above logic.

For all the `Node` classes, there are `match()` method inside. Let's check these methods one by one. First is the `match` method of `RootClassNode`:

![org.jboss.resteasy.core.registry.RootClassNode.match.png]({{ site.url }}/assets/org.jboss.resteasy.core.registry.RootClassNode.match.png)

From above diagram, we can see the call chain like this: `RootClassNode.match() -> ClassNode.match() -> RootNode.match()`. Now let's check the `match` method of `ClassNode`:

![org.jboss.resteasy.core.registry.ClassNode.match.png]({{ site.url }}/assets/org.jboss.resteasy.core.registry.ClassNode.match.png)

### _References_

---
